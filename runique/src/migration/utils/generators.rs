use crate::migration::utils::{
    helpers::col_type_to_method,
    types::{Changes, ParsedSchema},
};

pub fn generate_create_file(schema: &ParsedSchema) -> String {
    let mut cols = String::new();

    if let Some(ref pk) = schema.primary_key {
        cols.push_str(&format!(
            "                    .col(ColumnDef::new(Alias::new(\"{}\")).integer().not_null().auto_increment().primary_key())\n",
            pk.name
        ));
    }

    for col in schema.columns.iter().filter(|c| !c.ignored) {
        let type_method = col_type_to_method(&col.col_type);
        let null = if col.nullable {
            ".null()"
        } else {
            ".not_null()"
        };
        let unique = if col.unique { ".unique()" } else { "" };
        cols.push_str(&format!(
            "                    .col(ColumnDef::new(Alias::new(\"{}\")).{}{}{})\n",
            col.name, type_method, null, unique
        ));
    }

    let mut fk_stmts = String::new();
    for fk in &schema.foreign_keys {
        fk_stmts.push_str(&format!(
            "        manager\n            .create_foreign_key(\n                ForeignKey::create()\n                    .from(Alias::new(\"{}\"), Alias::new(\"{}\"))\n                    .to(Alias::new(\"{}\"), Alias::new(\"{}\"))\n                    .on_delete(ForeignKeyAction::{})\n                    .on_update(ForeignKeyAction::{})\n                    .to_owned(),\n            )\n            .await?;\n\n",
            schema.table_name, fk.from_column,
            fk.to_table, fk.to_column,
            fk.on_delete, fk.on_update
        ));
    }

    let mut idx_stmts = String::new();
    for idx in &schema.indexes {
        let cols_str = idx
            .columns
            .iter()
            .map(|c| format!("Alias::new(\"{}\")", c))
            .collect::<Vec<_>>()
            .join(", ");
        let unique = if idx.unique { ".unique()" } else { "" };
        idx_stmts.push_str(&format!(
            "        manager\n            .create_index(\n                Index::create()\n                    .name(\"{}\")\n                    .table(Alias::new(\"{}\"))\n                    .col({}){}\n                    .to_owned(),\n            )\n            .await?;\n\n",
            idx.name, schema.table_name, cols_str, unique
        ));
    }

    let mut fk_drops = String::new();
    for fk in &schema.foreign_keys {
        fk_drops.push_str(&format!(
            "        manager\n            .drop_foreign_key(\n                ForeignKey::drop()\n                    .table(Alias::new(\"{}\"))\n                    .name(\"{}_{}_{}_fkey\")\n                    .to_owned(),\n            )\n            .await?;\n\n",
            schema.table_name, schema.table_name, fk.from_column, fk.to_table
        ));
    }

    let mut idx_drops = String::new();
    for idx in &schema.indexes {
        idx_drops.push_str(&format!(
            "        manager\n            .drop_index(Index::drop().name(\"{}\").table(Alias::new(\"{}\")).to_owned())\n            .await?;\n\n",
            idx.name, schema.table_name
        ));
    }

    format!(
        "use sea_orm_migration::prelude::*;\n\n#[derive(DeriveMigrationName)]\npub struct Migration;\n\n#[async_trait::async_trait]\nimpl MigrationTrait for Migration {{\n    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {{\n        manager\n            .create_table(\n                Table::create()\n                    .table(Alias::new(\"{}\"))\n                    .if_not_exists()\n{}\n                    .to_owned(),\n            )\n            .await?;\n\n{}{}        Ok(())\n    }}\n\n    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {{\n{}{}        manager\n            .drop_table(Table::drop().table(Alias::new(\"{}\")).to_owned())\n            .await?;\n        Ok(())\n    }}\n}}\n",
        schema.table_name,
        cols.trim_end(),
        fk_stmts,
        idx_stmts,
        fk_drops,
        idx_drops,
        schema.table_name
    )
}

pub fn generate_alter_file(change: &Changes) -> String {
    let (up_body, down_body) = build_alter_bodies(change);
    format!(
        "use sea_orm_migration::prelude::*;\n\n#[derive(DeriveMigrationName)]\npub struct Migration;\n\n#[async_trait::async_trait]\nimpl MigrationTrait for Migration {{\n    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {{\n{}\n        Ok(())\n    }}\n\n    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {{\n{}\n        Ok(())\n    }}\n}}\n",
        up_body.trim_end(), down_body.trim_end()
    )
}

pub fn generate_batch_up_file(changes: &[&Changes], timestamp: &str) -> String {
    let mut body = String::new();
    for change in changes {
        append_up_ops(change, &mut body);
    }
    format!(
        "// Batch up - auto-generated by sea-orm-builder\n// Timestamp: {0}\n// Tables: {1}\nuse sea_orm_migration::prelude::*;\n\n#[derive(DeriveMigrationName)]\npub struct Migration;\n\n#[async_trait::async_trait]\nimpl MigrationTrait for Migration {{\n    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {{\n{2}\n        Ok(())\n    }}\n\n    async fn down(&self, _manager: &SchemaManager) -> Result<(), DbErr> {{\n        Ok(())\n    }}\n}}\n",
        timestamp,
        changes.iter().map(|c| c.table_name.as_str()).collect::<Vec<_>>().join(", "),
        body.trim_end()
    )
}

pub fn generate_batch_down_file(changes: &[&Changes], timestamp: &str) -> String {
    let mut body = String::new();
    for change in changes {
        append_down_ops(change, &mut body);
    }
    format!(
        "// Batch down - auto-generated by sea-orm-builder\n// Timestamp: {0}\n// Tables: {1}\nuse sea_orm_migration::prelude::*;\n\n#[derive(DeriveMigrationName)]\npub struct Migration;\n\n#[async_trait::async_trait]\nimpl MigrationTrait for Migration {{\n    async fn up(&self, _manager: &SchemaManager) -> Result<(), DbErr> {{\n        Ok(())\n    }}\n\n    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {{\n{2}\n        Ok(())\n    }}\n}}\n",
        timestamp,
        changes.iter().map(|c| c.table_name.as_str()).collect::<Vec<_>>().join(", "),
        body.trim_end()
    )
}

// ── internal helpers ────────────────────────────────────────────────────────

fn build_alter_bodies(change: &Changes) -> (String, String) {
    let mut up = String::new();
    let mut down = String::new();

    // drop index
    for idx in &change.dropped_indexes {
        push_drop_index(&mut up, &change.table_name, &idx.name);
    }
    for idx in &change.added_indexes {
        push_drop_index(&mut down, &change.table_name, &idx.name);
    }

    // drop FK
    for fk in &change.dropped_fks {
        push_drop_fk(&mut up, &change.table_name, &fk.from_column, &fk.to_table);
    }
    for fk in &change.added_fks {
        push_drop_fk(&mut down, &change.table_name, &fk.from_column, &fk.to_table);
    }

    // drop column
    for col_name in &change.dropped_columns {
        push_drop_column(&mut up, &change.table_name, col_name);
    }
    for col in &change.added_columns {
        push_drop_column(&mut down, &change.table_name, &col.name);
    }

    // modify column
    for (old, new) in &change.modified_columns {
        if old.col_type != new.col_type {
            up.push_str(&format!(
                "        // WARNING: type change on column '{0}': {1} -> {2}\n        // Manual migration required.\n\n",
                new.name, old.col_type, new.col_type
            ));
        } else {
            push_modify_column(
                &mut up,
                &change.table_name,
                &new.name,
                &new.col_type,
                new.nullable,
                new.unique,
            );
            push_modify_column(
                &mut down,
                &change.table_name,
                &old.name,
                &old.col_type,
                old.nullable,
                old.unique,
            );
        }
    }

    // add column
    for col in &change.added_columns {
        push_add_column(
            &mut up,
            &change.table_name,
            &col.name,
            &col.col_type,
            col.nullable,
            col.unique,
        );
    }
    for col_name in &change.dropped_columns {
        down.push_str(&format!(
            "        manager\n            .alter_table(\n                Table::alter()\n                    .table(Alias::new(\"{0}\"))\n                    .add_column(ColumnDef::new(Alias::new(\"{1}\")).string().not_null())\n                    .to_owned(),\n            )\n            .await?;\n\n",
            change.table_name, col_name
        ));
    }

    // add FK
    for fk in &change.added_fks {
        push_create_fk(
            &mut up,
            &change.table_name,
            &fk.from_column,
            &fk.to_table,
            &fk.to_column,
            &fk.on_delete,
            &fk.on_update,
        );
    }
    for fk in &change.dropped_fks {
        push_create_fk(
            &mut down,
            &change.table_name,
            &fk.from_column,
            &fk.to_table,
            &fk.to_column,
            &fk.on_delete,
            &fk.on_update,
        );
    }

    // add index
    for idx in &change.added_indexes {
        push_create_index(
            &mut up,
            &change.table_name,
            &idx.name,
            &idx.columns,
            idx.unique,
        );
    }
    for idx in &change.dropped_indexes {
        push_create_index(
            &mut down,
            &change.table_name,
            &idx.name,
            &idx.columns,
            idx.unique,
        );
    }

    (up, down)
}

fn append_up_ops(change: &Changes, buf: &mut String) {
    for idx in &change.dropped_indexes {
        push_drop_index(buf, &change.table_name, &idx.name);
    }
    for fk in &change.dropped_fks {
        push_drop_fk(buf, &change.table_name, &fk.from_column, &fk.to_table);
    }
    for col in &change.dropped_columns {
        push_drop_column(buf, &change.table_name, col);
    }
    for col in &change.added_columns {
        push_add_column(
            buf,
            &change.table_name,
            &col.name,
            &col.col_type,
            col.nullable,
            col.unique,
        );
    }
    for fk in &change.added_fks {
        push_create_fk(
            buf,
            &change.table_name,
            &fk.from_column,
            &fk.to_table,
            &fk.to_column,
            &fk.on_delete,
            &fk.on_update,
        );
    }
    for idx in &change.added_indexes {
        push_create_index(buf, &change.table_name, &idx.name, &idx.columns, idx.unique);
    }
}

fn append_down_ops(change: &Changes, buf: &mut String) {
    for idx in &change.added_indexes {
        push_drop_index(buf, &change.table_name, &idx.name);
    }
    for fk in &change.added_fks {
        push_drop_fk(buf, &change.table_name, &fk.from_column, &fk.to_table);
    }
    for col in &change.added_columns {
        push_drop_column(buf, &change.table_name, &col.name);
    }
    for col in &change.dropped_columns {
        buf.push_str(&format!(
            "        manager\n            .alter_table(\n                Table::alter()\n                    .table(Alias::new(\"{0}\"))\n                    .add_column(ColumnDef::new(Alias::new(\"{1}\")).string().not_null())\n                    .to_owned(),\n            )\n            .await?;\n\n",
            change.table_name, col
        ));
    }
    for fk in &change.dropped_fks {
        push_create_fk(
            buf,
            &change.table_name,
            &fk.from_column,
            &fk.to_table,
            &fk.to_column,
            &fk.on_delete,
            &fk.on_update,
        );
    }
    for idx in &change.dropped_indexes {
        push_create_index(buf, &change.table_name, &idx.name, &idx.columns, idx.unique);
    }
}

// ── low-level string pushers ────────────────────────────────────────────────

fn push_drop_index(buf: &mut String, table: &str, idx_name: &str) {
    buf.push_str(&format!(
        "        manager\n            .drop_index(Index::drop().name(\"{0}\").table(Alias::new(\"{1}\")).to_owned())\n            .await?;\n\n",
        idx_name, table
    ));
}

fn push_drop_fk(buf: &mut String, table: &str, from_col: &str, to_table: &str) {
    buf.push_str(&format!(
        "        manager\n            .drop_foreign_key(\n                ForeignKey::drop()\n                    .table(Alias::new(\"{0}\"))\n                    .name(\"{0}_{1}_{2}_fkey\")\n                    .to_owned(),\n            )\n            .await?;\n\n",
        table, from_col, to_table
    ));
}

fn push_drop_column(buf: &mut String, table: &str, col: &str) {
    buf.push_str(&format!(
        "        manager\n            .alter_table(\n                Table::alter()\n                    .table(Alias::new(\"{0}\"))\n                    .drop_column(Alias::new(\"{1}\"))\n                    .to_owned(),\n            )\n            .await?;\n\n",
        table, col
    ));
}

fn push_modify_column(
    buf: &mut String,
    table: &str,
    col: &str,
    col_type: &str,
    nullable: bool,
    unique: bool,
) {
    let null = if nullable { ".null()" } else { ".not_null()" };
    let uniq = if unique { ".unique()" } else { "" };
    buf.push_str(&format!(
        "        manager\n            .alter_table(\n                Table::alter()\n                    .table(Alias::new(\"{0}\"))\n                    .modify_column(ColumnDef::new(Alias::new(\"{1}\")).{2}{3}{4})\n                    .to_owned(),\n            )\n            .await?;\n\n",
        table, col, col_type_to_method(col_type), null, uniq
    ));
}

fn push_add_column(
    buf: &mut String,
    table: &str,
    col: &str,
    col_type: &str,
    nullable: bool,
    unique: bool,
) {
    let null = if nullable { ".null()" } else { ".not_null()" };
    let uniq = if unique { ".unique()" } else { "" };
    buf.push_str(&format!(
        "        manager\n            .alter_table(\n                Table::alter()\n                    .table(Alias::new(\"{0}\"))\n                    .add_column(ColumnDef::new(Alias::new(\"{1}\")).{2}{3}{4})\n                    .to_owned(),\n            )\n            .await?;\n\n",
        table, col, col_type_to_method(col_type), null, uniq
    ));
}

fn push_create_fk(
    buf: &mut String,
    table: &str,
    from_col: &str,
    to_table: &str,
    to_col: &str,
    on_delete: &str,
    on_update: &str,
) {
    buf.push_str(&format!(
        "        manager\n            .create_foreign_key(\n                ForeignKey::create()\n                    .from(Alias::new(\"{0}\"), Alias::new(\"{1}\"))\n                    .to(Alias::new(\"{2}\"), Alias::new(\"{3}\"))\n                    .on_delete(ForeignKeyAction::{4})\n                    .on_update(ForeignKeyAction::{5})\n                    .to_owned(),\n            )\n            .await?;\n\n",
        table, from_col, to_table, to_col, on_delete, on_update
    ));
}

fn push_create_index(
    buf: &mut String,
    table: &str,
    idx_name: &str,
    columns: &[String],
    unique: bool,
) {
    let cols_str = columns
        .iter()
        .map(|c| format!("Alias::new(\"{}\")", c))
        .collect::<Vec<_>>()
        .join(", ");
    let uniq = if unique { ".unique()" } else { "" };
    buf.push_str(&format!(
        "        manager\n            .create_index(\n                Index::create()\n                    .name(\"{0}\")\n                    .table(Alias::new(\"{1}\"))\n                    .col({2}){3}\n                    .to_owned(),\n            )\n            .await?;\n\n",
        idx_name, table, cols_str, uniq
    ));
}
